// Copyright 2016 UTK JICS AACE
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


//=============================================================
// 
//  stitch_blast_output.cpp
//
//  This code will scan all the output files generated by a
//  parallel HPC Blast(p) job and merge all the output from the
//  files into a single file preserving the order of the queries
//  as given by the original query file that distribute_queries
//  used.
//
//  Written by - Shane Sawyer
//
//=============================================================


#include <stdlib.h>
#include <string>
#include <cstring>
#include <iostream>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include <limits.h>
#include <stdint.h>
#include <sys/stat.h>
#include <cmath>
#include <ctype.h>
#include <new>
#include <map>
#include <unordered_map>
#include <vector>
#include <iterator>
#include <cassert>


#define max(a,b) ({ __typeof__ (a) _a = (a); \
  __typeof__ (b) _b = (b); \
  _a > _b ? _a : _b; })

#define min(a,b) ({ __typeof__ (a) _a = (a); \
  __typeof__ (b) _b = (b); \
  _a < _b ? _a : _b; })

inline bool file_exists(const std::string& name)
{
  struct stat buffer;
  return (stat (name.c_str(), &buffer) == 0);
}

struct sequence
{
  std::string id;
  std::string filename;
  uint64_t offsets[6];
};

struct score_info
{
  double score;
  double evalue;
  uint64_t index;
  uint64_t file_index;
  uint64_t score_start;
  uint64_t score_stop;
  uint64_t pairwise_start;
  uint64_t pairwise_stop;
};

int compare_scores ( const void *a, const void *b )
{
  const struct score_info * aa = (const struct score_info*)a;
  const struct score_info * bb = (const struct score_info*)b;

  if ( 1 )
    {
      if ( aa->evalue < bb->evalue )
	return -1;
      else if ( aa->evalue > bb->evalue )
	return 1;
      else
	{
	  if ( aa->score > bb->score )
	    return -1;
	  else if ( aa->score < bb->score )
	    return 1;
	  else
	    {
	      if ( aa->index < bb->index )
		return -1;
	      else if ( aa->index > bb->index )
		return 1;
	      else
		return 0;
	    }
	}
    }
  else
    {
      if ( aa->score > bb->score )
	return -1;
      else if ( aa->score < bb->score )
	return 1;
      else
	{
	  if ( aa->evalue > bb->evalue )
	    return -1;
	  else if ( aa->evalue < bb->evalue )
	    return 1;
	  else
	    return 0;
	}
    }
}

int main(int argc, char* argv[])
{

  // Variable declaration block. ---------------------------------------------------------
  uint64_t num_thread_groups;                                    // Number of query distributions per rank.
  uint64_t num_team_leaders;                                     // Number of database partitions per thread group.
  uint64_t num_ranks_per_group;                                  // Number of database partitions for the job.
  uint64_t num_replication_groups;                               // Number of query distributions for the job.
  uint64_t num_ranks_total;                                      // Total number of ranks in the job.
  uint64_t g_rank;                                               // Global rank -- loop counter.
  uint64_t i, j;                                                 // Loop counters.
  uint64_t k, l;                                                 // Additional loop counters.
  uint64_t pos;                                                  // Position in the buffer.
  uint64_t pos_beg, pos_end;                                     // Beginning and ending of a substring in the buffer.
  uint64_t query;                                                // A query index (for loop counting).
  uint64_t num_alignments;                                       // Number of alignments for a given query.
  uint64_t num_scores;                                           // Number of score lines for a given query.
  uint64_t num_scores_processed;                                 // Number of score lines processed for the queries. Index to the current working score line.
  uint64_t num_alignments_processed;                             // Number of alignments processed for the queries. Index to the current working alignment.
  uint64_t alignment_ptr;                                        // Keeps track of where the score structs were first inserted into the array at the beginning of the file.
  uint64_t line_start;                                           // The position in a buffer of the start of new line.
  const uint64_t score_array_length = 30;                        // Length of the array that holds the characters representing the scores of the alignment (bit score and evalue).
  const uint64_t MAX_FILE_NAME_LEN = 276;

  bool is_def_line;                                              // Flag to indicate if the '>' character starts a defline (a new query) or appears somewhere in the defline and is not a new query.
  bool found_length;                                             // Flag to indicate if the length of the query had been found or not.
  bool found_hits;                                               // Flag to indicate if alignments were found for this query in the current file.
  bool found_list;                                               // Flag to indicate if the beginning of the list of alignments was found.
  bool found_end;                                                // Flag to indicate if the end of the list of alignments and the end of the query block for this file had been found.

  char score_array[score_array_length];                          // The array to hold the scores in  string form.
  char input_file_name[MAX_FILE_NAME_LEN];
  char output_file_name[MAX_FILE_NAME_LEN];
  uint64_t if_length;                                            // Input file length.
  uint64_t of_length;                                            // Output file length.

  uint64_t num_vbars;                                            // Number of vertical bars encountered. This is for stripping out the query ID tag.
  char qids_unsorted[MAX_FILE_NAME_LEN];                         // Name of file containing all the query IDs in the original order.
  std::string print_string;                                      // String to print to screen.

  uint64_t length;                                               // Length of the input file in bytes.  
  char *buffer = 0;                                              // Memory buffer for the input file.
  uint64_t buffer_size;                                          // Size of the buffer in bytes.
  uint64_t num_queries;
  uint64_t *query_offsets = 0;                                   // Offsets into the buffer for the start of the queries.
  uint64_t current_query;
  uint64_t *q_lengths = 0;                                       // The array that hold the lengths of the queries in the input.
  uint64_t *query_lengths = 0;                                   // Pointer to the query lengths.
  uint64_t current_query_length;
  bool start_counting;                                           // Flag to indicate length of the sequence may be counted.
  bool look_for_annotation_end;                                  // Flag to indicate that we should look for the end of the def line.
  bool keep_looking;                                             // Flag to indicate that we should continue to look for the end of a bit score or evaule.
  uint64_t partition;                                            // Loop counter over number of partitions applied to the input query file.

  std::stringstream sstm;                                        // A temporary string stream for making file names.
  std::string filename;                                          // A temporary string to hold the contents of the stringstream.
  std::string query_id;                                          // String holding the query identifier from the file.
  std::string score_string;                                      // Convert the score_array to a string for converting to a numerical value.

  std::ifstream ifs;                                             // Input file stream.
  std::ofstream ofs;                                             // Output file stream.

  const uint64_t BUFF_SIZE = 10000;                              // Buffer length for the prologue and epilogue.
  char prologue[BUFF_SIZE];                                      // The prologue for the job.
  char epilogue[BUFF_SIZE];                                      // The epilogue for the job.
  uint64_t pro_length;
  uint64_t epi_length;

  int max_score_lines = 0;                                       // Track the maximum number of score lines seen in any file.
  int max_alignments = 0;                                        // Track the maximum number of alignments seen in any file.

  const uint64_t BUFFER_SIZE = 53687091200;                      // Fix the buffer size to be at most 50GB (50*2^30).

  std::unordered_map< std::string, int > uno_map;                // Unordered map to hold the string identifiers and the index in which they appear.
  std::unordered_map<std::string,int>::const_iterator iter;      // Iterator over the unordered map.
  //std::vector<sequence> query_vector;                            // Vector of sequence structs. The struct contains the necessary information to retrieve data from the buffered file.
  std::vector< std::vector< sequence > > query_vector;           // Vector of vector of sequence structs. The first vector is to hold all the queries. Then for each query, we hold a
                                                                 //   vector of sequence structs that give us information to the loctations in files.
  std::map<std::string,int> filenames_map;                       // A set containing the file names used by a query. The integer values is used to give an order to the files.
  uint64_t num_files;                                            // Total number of files the query is associated with.
  uint64_t total_buffer_length;                                  // The total length required by all files associates with the query.
  uint64_t *file_lengths = 0;                                    // Lengths of the individual files.
  char **file_buffers = 0;                                       // The actual file buffers.
  uint64_t index;                                                // The index of a file in the map (the order in which it appears in the vector).
  uint64_t length_to_write;                                      // The length of the buffer to write to the output file.

  struct score_info *alignment_scores = 0;                       // Array of structs to hold scores to be sorted for correct output order.
  // End variable declaration block. -----------------------------------------------------
  
  // Check the command line.

  if ( argc < 2 )
    {
      std::cout<<"Error: an input file name must be given. This is the name of the output file specified by the parallel job for HPC-BLAST."<<std::endl;
      std::cout<<"       ./stitch_blast_output <BLAST output file name>  <optional name of single output file>"<<std::endl;
      std::cout.flush();
      exit(1);
    }
  else if ( argc < 3 )   // Assume we got the input file for now.
    {
      strncpy(input_file_name, argv[1], (MAX_FILE_NAME_LEN-20));
      strncpy(output_file_name, input_file_name, (MAX_FILE_NAME_LEN-20));
    }
  else if ( argc < 4 )   // Assume we got both the input and output file names.
    {
      strncpy(input_file_name, argv[1], (MAX_FILE_NAME_LEN-20));
      strncpy(output_file_name, argv[2], (MAX_FILE_NAME_LEN-20));
    }
  else
    {
      std::cout<<"Error: too many inputs given on the command line."<<std::endl;
      std::cout<<"       ./stitch_blast_output <BLAST output file name>  <optional name of single output file>"<<std::endl;
      std::cout.flush();
      exit(1);
    }
  
  
  // Test for existence of the job parameters file (job_params).

  if ( file_exists("job_params") )
    {
      std::ifstream job_input("job_params");
      job_input >> num_thread_groups >> num_team_leaders >> num_ranks_per_group >> num_replication_groups;

num_thread_groups=1;
num_team_leaders=1;

      job_input.close();
    }
  else
    {
      std::cerr<<"FATAL ERROR: job_params file not found!"<<std::endl;
      std::cerr.flush();
    }

  num_ranks_total = num_ranks_per_group * num_replication_groups;
  
  // Test for existence of the query identifiers file written when the queries were distributed.
  
  if ( file_exists("query_ids.unsorted") )
    {
      std::ifstream job_input("query_ids.unsorted");

      // Read in the file and construct the unordered map.
      i = 0;
      
      while ( job_input.good() )
	{
	  std::getline( job_input, query_id );
	  
	  if ( query_id.length() < 3 )   // Catch the empty line.
	    break;
      
	  uno_map.insert( std::pair<std::string,int> (query_id, i) );

	  ++i;
	}

      job_input.close();
    }
  else
    {
      std::cerr<<"FATAL ERROR: query_ids.unsorted file not found!"<<std::endl;
      std::cerr.flush();
    }

  // Get the number of queries.
  num_queries = uno_map.size();

  //std::cout<<"The unordered map is reporting "<<num_queries<<". And i="<<i<<std::endl;

  // Resize the vector of vectors now that we know the number of queries.
  query_vector.resize( num_queries );

  // Loop over the files that are implied to exist from the job parameters and input file to check for existence and determine the largest of these files.
  buffer_size = 0;
  for ( i=0; i < num_replication_groups; ++i )
    {
      for ( j=0; j < num_ranks_per_group; ++j )
	{
	  for ( k=0; k < num_thread_groups; ++k )
	    {
	      for ( l=0; l < num_team_leaders; ++l )
		{
		  sstm.str(std::string());   // clear out internal string.
		  
		  if ( num_ranks_total > 1 )
		    {
		      //g_rank = i*num_replication_groups + j;
		      g_rank = i*num_ranks_per_group + j;
		      sstm << input_file_name << "." << g_rank << "." << i << "." << j << "." << k << "." << l;
		    }
		  else
		    sstm << input_file_name << "." << i << "." << j << "." << k << "." << l;
		  
		  filename.assign( sstm.str() );
		  
		  if ( file_exists( filename ) )
		    {
		      ifs.open(filename, std::ifstream::binary );
		      
		      // Get the length of the file.
		      ifs.seekg(0,ifs.end);
		      length = ifs.tellg();
		      
		      buffer_size = max( buffer_size, length );
		      
		      ifs.close();
		    }
		  else
		    {
		      std::cerr<<"ERROR: file <"<<filename<<"> was not found. Check that it should exist."<<std::endl;
		      std::cerr.flush();
		      exit(1);
		    }
		}
	    }
	}
    }

  // Now have the size of the largest file. Use that to allocate the buffer once, since all files will fit in it.
  try
    {
      buffer = new char[buffer_size];
    }
  catch ( std::bad_alloc &exc )
    {
      std::cerr<<"Allocation for buffer failed. bad_alloc caught."<<std::endl;
      std::cerr<<"Attempted to allocate "<<buffer_size<<" bytes."<<std::endl;
      std::cerr.flush();
      exit(1);
    }


  // Now we loop over all the files, read them into the buffer, and scan them for the offsets.
  for ( i=0; i < num_replication_groups; ++i )
    {
      for ( j=0; j < num_ranks_per_group; ++j )
	{
	  for ( k=0; k < num_thread_groups; ++k )
	    {
	      for ( l=0; l < num_team_leaders; ++l )
		{
		  sstm.str(std::string());   // clear out internal string.

		  if ( num_ranks_total > 1 )
		    {
		      //g_rank = i*num_replication_groups + j;
		      g_rank = i*num_ranks_per_group + j;
		      sstm << input_file_name << "." << g_rank << "." << i << "." << j << "." << k << "." << l;
		    }
		  else
		    sstm << input_file_name << "." << i << "." << j << "." << k << "." << l;
		  
		  filename.assign( sstm.str() );
		  
		  //std::cout<<"Reading file "<<filename<<std::endl;
		  
		  ifs.open(filename, std::ifstream::binary);
		  
		  // Get the length of the file.
		  ifs.seekg(0,ifs.end);
		  length = ifs.tellg();
		  
		  // Copy the file to the buffer.
		  ifs.seekg(0,ifs.beg);
		  ifs.read(buffer,length);
		  ifs.close();

		  //std::cout<<"File has "<<length<<" bytes."<<std::endl;
		  
		  // For all queries in the file, find the queries identifier and the buffer offsets.
		  
		  // Find the start of the query; i.e. "Query="
		  for ( pos=0; pos < length; ++pos )
		    {
		      if ( buffer[pos] != 'Q' )
			continue;
		      
		      // found a Q : debug
		      //std::cout<<"  Found a Q:"<<std::endl;
		      //std::cout<<"  pos="<<pos<<" "<<buffer[pos]<<buffer[pos+1]<<buffer[pos+2]<<buffer[pos+3]<<buffer[pos+4]<<buffer[pos+5]<<std::endl;
		      //std::cout<<"  string compare yields "<<( strncmp( &(buffer[pos]), "Query=", 6 ) )<<std::endl;

		      // Found a 'Q' if we are here. Now test if this is part of "Query="
		      if ( pos > (length-10) )   // Couldn't possibly be a query.
			continue;
		      
		      if ( strncmp( &(buffer[pos]), "Query=", 6 ) == 0 )   // Found a query.
			{
			  //std::cout<<"  found Query= at position "<<pos<<std::endl;
			  
			  struct sequence seq;
			  
			  // Save the filename it occured in.
			  seq.filename.assign(filename);

			  // Save the start of the query in the file.
			  assert(pos < length);
			  seq.offsets[0] = pos;
			  
			  // Find the query identifier in a consistent manner as they were in distribute_queries.cpp
			  // Current method is to look 20 characters down from the start of the query.
			  num_vbars = 0;
			  pos_beg = pos+7;   // Assumes there is always a space after the '=' character.
			  pos_end = pos_beg;
			  
			  while ( num_vbars < 20 )
			    {
			      if ( pos_end >= length )
				{
				  num_vbars = 22;
				  break;
				}
			      else if ( buffer[pos_end] == '\n' || ((pos_end-pos_beg)==20) )
				{
				  num_vbars = 22;
				  break;
				}
			      
			      ++pos_end;
			    }
			  
			  if ( (pos_end-pos_beg) < 6 || (pos_end-pos_beg) > 20 )
			    {
			      seq.id.assign( &(buffer[pos_beg] ), 20 );
			    }
			  else
			    {
			      seq.id.assign( &(buffer[pos_beg]), (pos_end-pos_beg) );
			    }

			  //std::cout<<"  the sequence id is "<<seq.id<<std::endl;
			  
			  // Find the remaining offsets. I will implement this with another loop over the position, but can hopefully terminate it before it goes too far.
			  found_length = false;
			  for ( pos_beg=pos_end; pos_beg < length; ++pos_beg )
			    {
			      // I will also accept responsibility for buffer overruns for now.
			      if ( buffer[pos_beg] != 'L' )
				continue;
			      
			      if ( strncmp( &(buffer[pos_beg]), "Length=", 7 ) == 0 )
				{
				  // Advance the position.
				  pos_beg += 7;
				  
				  found_length = true;
				  break;
				}
			      
			    }

			  if ( pos_beg >= length || !found_length )
			    {
			      std::cerr<<"ERROR: file < "<<filename<<" >. At buffer position "<<pos_beg<<std::endl;
			      std::cerr<<"  Some context:"<<std::endl;
			      filename.assign( &(buffer[seq.offsets[0]]), 100 );
			      std::cerr<<filename<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }

			  while ( buffer[pos_beg] != '\n' && pos_beg < length )
			    {
			      ++pos_beg;
			    }

			  // Check that I didn't somehow run off the end of the file.
			  if ( pos_beg >= length )
			    {
			      // I ran off the file.
			      std::cerr<<"ERROR: in file "<<filename<<", I ran off the end of the buffer looking for Length="<<std::endl;
			      std::cerr<<"  The query I was examining was "<<seq.id<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }

			  // Ok, found the length and found the end of the line. Now let's see if we found any hits or not.
			  if ( ( buffer[pos_beg+1] == '\n' && buffer[pos_beg+2] == '\n' ) && buffer[pos_beg+3] == '*' )
			    {
			      //std::cout<<"  didn't find any hits for this sequence."<<std::endl;
			      
			      //found no hits.
			      found_hits = false;

			      // Set offsets array indices 1-5 to 0 to indicate this sequence entry has no hits.
			      seq.offsets[1] = 0;
			      seq.offsets[2] = 0;
			      seq.offsets[3] = 0;
			      seq.offsets[4] = 0;
			      seq.offsets[5] = 0;
			    }
			  else if ( buffer[pos_beg+1] == ' ')   // should be hits.
			    {
			      pos_beg += 1;
			      found_hits = true;
			    }
			  else
			    {
			      std::cerr<<"ERROR: Something unexpected happened while looking for the start of the significant alignments found for the query."<<std::endl;
			      std::cerr<<"  The file is "<<seq.filename<<" and the query is "<<seq.id<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }
			  
			  if ( found_hits )
			    {
			      // Move the buffer position until I find "e\n\n" sequence.
			      found_list = false;
			      while ( !found_list && pos_beg < (length-3) )
				{
				  if ( (buffer[pos_beg] == 'e' &&
					buffer[pos_beg+1] == '\n' ) &&
				        buffer[pos_beg+2] == '\n' )
				    {
				      found_list = true;
				      assert( (pos_beg+3) < length );
				      seq.offsets[1] = pos_beg+3;
				      pos_beg += 3;
				    }
				  
				  else
				    pos_beg += 1;
				}
			      
			      if ( !found_list )
				{
				  std::cerr<<"ERROR: Something unexpected happened while looking for the start of the significant alignments found for the query."<<std::endl;
				  std::cerr<<"  The file is "<<seq.filename<<" and the query is "<<seq.id<<std::endl;
				  std::cerr.flush();
				  exit(1);
				}
			      
			      // Find the end of the list of sequences aligning with the query.
			      found_list = false;
			      while ( !found_list && pos_beg < (length-3) )
				{
				  if ( (buffer[pos_beg] == '\n' &&
					buffer[pos_beg+1] == '\n' ) &&
				        buffer[pos_beg+2] == '\n' )
				    {
				      found_list = true;
				      assert( (pos_beg+3) < length );
				      seq.offsets[2] = pos_beg+1;
				      seq.offsets[3] = pos_beg+3;
				      pos_beg += 3;
				    }
				  
				  else
				    pos_beg += 1;
				}
			      
			      if ( !found_list )
				{
				  std::cerr<<"ERROR: Something unexpected happened while looking for the end of the score block for the query."<<std::endl;
				  std::cerr<<"  The file is "<<seq.filename<<" and the query is "<<seq.id<<std::endl;
				  std::cerr.flush();
				  exit(1);
				}
			      
			      // Find the end of the alignments for the query in this file.
			      found_end = false;
			      while ( !found_end && pos_beg < (length-5) )
				{
				  if ( (buffer[pos_beg] == '\n' &&
					buffer[pos_beg+1] == '\n' ) &&
				       (buffer[pos_beg+2] == '\n' &&
					buffer[pos_beg+3] == '\n') &&
				        buffer[pos_beg+4] == 'L' )
				    {
				      found_end = true;
				      assert( (pos_beg+3) < length );
				      seq.offsets[4] = pos_beg+3;
				      pos_beg += 5;
				    }
				  
				  else
				    pos_beg += 1;
				}
			      
			      if ( !found_end )
				{
				  std::cerr<<"ERROR: Something unexpected happened while looking for the end of the pairwise alignments for the query."<<std::endl;
				  std::cerr<<"  The file is "<<seq.filename<<" and the query is "<<seq.id<<std::endl;
				  std::cerr.flush();
				  exit(1);
				}
			      
			      found_end = false;
			      while ( !found_end && pos_beg < (length-6) )
				{
				  if ( (buffer[pos_beg] == '\n' &&
					buffer[pos_beg+1] == '\n' ) &&
				        buffer[pos_beg+2] == '\n' )
				    {
				      if  ( buffer[pos_beg+3] == 'Q' ||
					    ( (buffer[pos_beg+3] == ' ' &&
					       buffer[pos_beg+4] == ' ' ) &&
					       buffer[pos_beg+5] == 'D' ) )
					{
					  found_end = true;
					  assert( (pos_beg+3) < length );
					  seq.offsets[5] = pos_beg+3;
					}
				      else
					pos_beg += 1;
				    }
				  
				  else
				    pos_beg += 1;
				}
			      
			      if ( !found_end )
				{
				  std::cerr<<"ERROR: Something unexpected happened while looking for the end of the query block in the file."<<std::endl;
				  std::cerr<<"  The file is "<<seq.filename<<" and the query is "<<seq.id<<std::endl;
				  std::cerr.flush();
				  exit(1);
				}
			    }   // End of if block on found_hits condition.
			      
			  // Now I have to store the sequence in the vector so that I can easily write out the file?
			  // The order of the replication group rank and the team leader rank enforce an ordering the alignments.

			  // Find the index of the query in the global sense.
			  iter = uno_map.find( seq.id );
			  
			  if ( iter == uno_map.end() )
			    {
			      std::cerr<<"ERROR: The query < "<<seq.id<<" > from file "<<seq.filename<<" was not found in the map."<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }
			  else
			    {
			      //std::cout<<"  the sequence was found in the unordered map at position "<<iter->second<<std::endl;
			      
			      // We can now put the information into the vector.
			      query_vector[ iter->second ].push_back( seq );
			    }
			  
			}
		      else   // False positive.
			continue;
		    }   // End of the loop over the buffer. <pos>
		  
		}   // End of the loop over the number of team leaders. <l>
	    }   // End of the loop over the number of thread groups. <k>
	}   // End of the loop over the number of ranks per replication group. <j>
    }   // End of the loop over the number of replication groups. <i>
 
  for ( query=0; query < num_queries; ++query )
    {
      //std::cout<<"Query "<<query<<" has "<<query_vector[query].size()<<" entries in its vector."<<std::endl;
    }

  // All files have been parsed and query offsets copied into the query_vector data structure.

  // Now we can write out all the queries in order.
  
  // First we find the prologue and epilogue in the first file and save them to buffers so we can write them out.
  {
    sstm.str(std::string());

    if ( num_ranks_total > 1 )
      sstm << input_file_name << ".0.0.0.0.0";
    else
      sstm << input_file_name << ".0.0.0.0";
    filename.assign( sstm.str() );

    ifs.open(filename, std::ifstream::binary);

    // Get the length of the file.
    ifs.seekg(0,ifs.end);
    length = ifs.tellg();

    // Copy the file to the buffer.
    ifs.seekg(0,ifs.beg);
    ifs.read(buffer,length);
    ifs.close();

    pro_length = 0;
    epi_length = 0;

    for ( pos=0; pos < BUFF_SIZE; ++pos )
      {
	prologue[pos] = '\0';
	epilogue[pos] = '\0';
      }

    for ( pos=0; (pos < BUFF_SIZE) && (pos < length); ++pos )
      {
	// Find the offset position of the first instance of "Query=" since this will be the end of the prologue.
	if ( buffer[pos] != 'Q' )
	  continue;

	if ( strncmp( &(buffer[pos]), "Query=", 6 ) == 0 )
	  {
	    strncpy( &(prologue[0]), &(buffer[0]), pos );
	    //prologue[pos] = '\0';
	    pro_length = pos-1;
	  }
      }

    if ( pro_length == 0 )
      {
	std::cerr<<"ERROR: The prologue was not found in the first file, "<<filename<<std::endl;
	std::cerr.flush();
	exit(1);
      }

    uint64_t start_position=pos;
    if (length>BUFF_SIZE) {
      start_position=length-BUFF_SIZE;
    }

    for ( pos=start_position; pos < (length-10); ++pos )
      {
	if ( strncmp( &(buffer[pos]), "  Database", 10 ) == 0 )
	  {
	    strncpy( &(epilogue[0]), &(buffer[pos]), (length-pos) );
	    //epilogue[(length-pos)] = '\0';
	    epi_length = (length-pos);
	  }
      }

    if ( epi_length == 0 )
      {
	std::cerr<<"ERROR: The epilogue was not found in the first file, "<<filename<<std::endl;
	std::cerr.flush();
	exit(1);
      }
  }   // End of the block for finding the prologue and epilogue.

  // Open the file for writing.
  ofs.open( output_file_name, std::ofstream::out | std::ofstream::binary );

  // Write the prologue.
  ofs.write( &(prologue[0]), pro_length );

  // Loop over all the queries in the vector. Open the file, read it into the buffer. Write out all data to the output file.
  for ( query=0; query < num_queries; ++query )
    {
      // Loop over all the entries in the vector for this query and put the file names that are associated with this query in the map.

      std::string query_name;

      for ( iter = uno_map.begin(); iter != uno_map.end(); ++iter )
	{
	  if ( iter->second == query )
	    {
	      query_name.assign( iter->first );
	      break;
	    }
	}

      i = 0;
      for ( std::vector<sequence>::iterator it = query_vector[query].begin(); it != query_vector[query].end(); ++it )
	{
	  sequence & seq = *it;

	  filename.assign( seq.filename );

	  // Put the filename in the set.
	  std::pair<std::map<std::string,int>::iterator,bool> result = filenames_map.insert( std::pair<std::string,int> (filename,i) );

	  if ( result.second == true )
	    ++i;
	}

      num_files = filenames_map.size();

      assert( i == num_files );

      //std::cout<<"For query "<<query<<", with ID "<<query_name<<","<<" found "<<num_files<<std::endl;
      //std::cout.flush();

      // Output for debugging.
      if ( num_files > 0 )
        {
	  //std::vector<sequence>::const_iterator it = query_vector[query].begin();
	  //const sequence &seq = *it;
	  
	  //std::cout<<"  The query is "<<seq.id<<std::endl;
	  //std::cout.flush();
	}

      // Allocate the needed arrays.
      file_lengths = 0;
      file_buffers = 0;

      try
	{
	  file_buffers = new char*[num_files];
	}
      catch ( std::bad_alloc &exc )
	{
	  std::cerr<<"Allocation for file_buffers failed. bad_alloc caught."<<std::endl;
	  std::cerr<<"Attempted to allocate "<<num_files<<" pointers."<<std::endl;
	  std::cerr.flush();
	  exit(1);
	}

      try
	{
	  file_lengths = new uint64_t[num_files];
	}
      catch ( std::bad_alloc &exc )
	{
	  std::cerr<<"Allocation for file_lengths failed. bad_alloc caught."<<std::endl;
	  std::cerr<<"Attempted to allocate "<<num_files<<" entries."<<std::endl;
	  std::cerr.flush();
	  exit(1);
	}

      for ( i=0; i < num_files; ++i )
	file_lengths[i] = 0;

      // Now loop over all the entries in the set, get the file lengths, allocate the buffer, and copy the file to the buffer.
      total_buffer_length = 0;
      i = 0;
      for ( std::map<std::string,int>::iterator map_itr = filenames_map.begin(); map_itr != filenames_map.end(); ++map_itr )
	{
	  std::string filename_str = map_itr->first;
	  i = map_itr->second;

	  ifs.open(filename_str, std::ifstream::binary);

	  // Get the length of the file.
	  ifs.seekg(0,ifs.end);
	  length = ifs.tellg();

	  // Add it to the array and the current total length.
	  file_lengths[i] = length;
	  total_buffer_length += length;

	  //std::cout<<"**  File "<<map_itr->first<<"(index "<<i<<") has length "<<length<<" ("<<file_lengths[i]<<")."<<std::endl;

	  if ( total_buffer_length >= BUFFER_SIZE )
	    {
	      std::cerr<<"ERROR: The total space required for all the files is too large. Working on file "<<(i+1);
	      std::cerr<<". It is "<<length<<" bytes long and "<<(total_buffer_length-length)<<" bytes have already been read"<<std::endl;
	      std::cerr.flush();
	      exit(1);
	    }

	  // Allocate the buffer for this file.
	  try
	    {
	      file_buffers[i] = new char[length];
	    }
	  catch ( std::bad_alloc &exc )
	    {
	      std::cerr<<"Allocation for file_buffers["<<i<<"] failed. bad_alloc caught."<<std::endl;
	      std::cerr<<"Attempted to allocate "<<length<<" bytes."<<std::endl;
	      std::cerr.flush();
	      exit(1);
	    }
	  
	  // Copy the file to the buffer.
	  ifs.seekg(0,ifs.beg);
	  ifs.read(file_buffers[i],length);
	  ifs.close();

	}   // End of the loop over the map of filenames.
      
      // Loop over all entries in the vector. Write the relevant info from the buffer(s) to the output file.
      // Output consists of the following:
      //   1: The header for the sequence. Written once.
      //   2: The list of all sequences that produce significant alignments. Each entry in the vector can potentially contribute to this. If none do, we say that no hits were found.
      //   3: The list of all the actual alignments, if any were found.
      //   4: The ending header for the sequence displaying the statistical information. This also appears exactly once.

      // Task 1: Write the header.
      found_hits = false;   // Assume no hits until proven otherwise.
      for ( std::vector<sequence>::const_iterator it = query_vector[query].begin(); it != query_vector[query].end(); ++it )
	{
	  const sequence &seq = *it;

	  if ( seq.offsets[1] != 0 )
	    {
	      found_hits = true;

	      // Get the value (index) from the map.
	      std::map<std::string,int>::const_iterator map_iter;
	
	      map_iter = filenames_map.find( seq.filename );
	  
	      uint64_t index = map_iter->second;
	  
	      pos = seq.offsets[0];
	      length_to_write = seq.offsets[1] - seq.offsets[0];

	      ofs.write( &(file_buffers[index][pos]), length_to_write );

	      it = query_vector[query].end();

	      break;
	    }
	}

      if ( !found_hits )
	{
	  // HANDLE THIS HERE OR FIX IT EARLIER!

	  // Use the first entry to get the information we need.

	  std::vector<sequence>::const_iterator it = query_vector[query].begin();

	  const sequence &seq = *it;

	  //std::cout<<"Query "<<query<<" claims to have no hits."<<std::endl;
	  //std::cout<<" this query is identified as "<<seq.id<<std::endl;
	  //std::cout.flush();
	  // Get the value (index) from the map.

	  std::map<std::string,int>::const_iterator map_iter;
	  map_iter = filenames_map.find( seq.filename );
	  uint64_t index = map_iter->second;

	  //std::cout<<"  Looking in file "<<map_iter->first<<std::endl;
	  
	  // Now we scan the file from the beginning of this query until the next query or until the end of the file.

	  for ( pos=(seq.offsets[0]+1); pos < (file_lengths[index]-10); ++pos )
	    {
	      if ( strncmp( &(file_buffers[index][pos]), "Query=", 6 ) == 0 )
		{
		  //std::cout<<"     Found the start of another query."<<std::endl;
		  break;
		}

	      if ( strncmp( &(file_buffers[index][pos]), "  Database", 10 ) == 0 )
		{
		  //std::cout<<"     Found the end of the file."<<std::endl;
		  break;
		}
	    }

	  if ( pos == (file_lengths[index]-10) )
	    {
	      std::cerr<<"ERROR: Could not find the query block for query "<<seq.id<<" which had no hits."<<std::endl;
	      std::cerr.flush();
	      exit(1);
	    }

	  // Write the 'no hits' query block.
	  length_to_write = pos - seq.offsets[0];
	  pos = seq.offsets[0];
	  
	  ofs.write( &(file_buffers[index][pos]), length_to_write );

	  // Continue to the next query since this one is done now.
	  // But we still have to clear out the memory allocated for this iteration.

	  if ( file_lengths != 0 )
	    delete []file_lengths;
	  file_lengths = 0;

	  if ( alignment_scores != 0 )
	    delete [] alignment_scores;
	  alignment_scores = 0;

	  for ( i=0; i < num_files; ++i )
	    {
	      if ( file_buffers[i] != 0  && file_buffers != 0 )
		delete [] file_buffers[i];
	    }
	  
	  if ( file_buffers != 0 )
	    delete [] file_buffers;
	  file_buffers = 0;
	  
	  num_files = 0;
	  total_buffer_length = 0;
	  
	  filenames_map.clear();

	  continue;
	}   // End of the if test found_hits.

      // This query has alignments present. Sort the alignments by ascending Bit Score and and descending Evalue. Then we can write
      // out the scores list and alignments in this order to match (at least more closely) the order produced by NCBI BLAST.

      // First: find out how many alignments there are for this query. Loop over each file entry and determine the number of alignments.
      num_alignments = 0;
      num_scores = 0;

      for ( std::vector<sequence>::const_iterator it = query_vector[query].begin(); it != query_vector[query].end(); ++it )
	{
	  const sequence & seq = *it;

	  if ( seq.offsets[1] != 0 )
	    {
	      // Get the value (index) from the map.
	      std::map<std::string,int>::const_iterator map_iter;

	      map_iter = filenames_map.find( seq.filename );

	      uint64_t index = map_iter->second;

	      if ( seq.offsets[2] >= file_lengths[index] )
		{
		  std::cerr<<"Working on Query "<<query<<std::endl;
		  std::cerr<<"  the sequence object has ID "<<seq.id<<std::endl;
		  std::cerr<<"  file name is "<<seq.filename<<", and map_iter->first is "<<map_iter->first<<std::endl;
		  std::cerr<<"seq.offsets[2] is "<<seq.offsets[2]<<" and the file is length "<<file_lengths[index]<<std::endl;
		  std::cerr.flush();
		}

	      assert( seq.offsets[2] < file_lengths[index] );
	     
	      // Loop over the score block and count new lines, each of which will signify the presence of a subject match.
	      for ( pos=seq.offsets[1]; pos < seq.offsets[2]; ++pos )
		{
		  if ( file_buffers[index][pos] == '\n' )
		    num_scores += 1;
		}
	    }
	}

      // debug output
      //std::cout<<"Query "<<query<<" is reporting "<<num_scores<<" scores across all files."<<std::endl;

      // Second: allocate data structures and initialize them.
      try
	{
	  alignment_scores = new score_info[num_scores];
	}
      catch ( std::bad_alloc &exc )
	{
	  std::cerr<<"Allocation for alignment_scores failed. bad_alloc caught."<<std::endl;
	  std::cerr<<"Attempted to allocate "<<num_scores<<" structs for query "<<query<<"."<<std::endl;
	  std::cerr.flush();
	  exit(1);
	}

      for ( i=0; i < num_scores; ++i )
	{
	  alignment_scores[i].score = 0.;
	  alignment_scores[i].evalue = 0.;
	  alignment_scores[i].index = 0;
	  alignment_scores[i].file_index = 0;
	  alignment_scores[i].score_start = 0;
	  alignment_scores[i].score_stop = 0;
	  alignment_scores[i].pairwise_start = 0;
	  alignment_scores[i].pairwise_stop = 0;
	}

      // Third: fill in the data structures by scanning over the files. This step includes going through the file buffers twice
      //        as we have to find the score information and the actual pairwise alignments separately.

      // third - part a: get the score line information.
      num_scores_processed = 0;
      num_alignments_processed = 0;
      
      for ( std::vector<sequence>::const_iterator it = query_vector[query].begin(); it != query_vector[query].end(); ++it )
	{
	  const sequence & seq = *it;

	  if ( seq.offsets[1] != 0 )
	    {
	      // Get the value (index) from the map.
	      std::map<std::string,int>::const_iterator map_iter;

	      map_iter = filenames_map.find( seq.filename );

	      uint64_t index = map_iter->second;

	      // Save the starting position for this file.
	      alignment_ptr = num_scores_processed;
	      
	      pos = seq.offsets[1];

	      //std::cout<<"  Working in file "<<seq.filename<<std::endl;
	      //std::cout.flush();

	      while ( pos < seq.offsets[2] )   // Loop over the score lines.
		{
		  alignment_scores[num_scores_processed].file_index = index;
		  alignment_scores[num_scores_processed].score_start = pos;
		  alignment_scores[num_scores_processed].index = num_scores_processed;

		  //std::cout<<"For query "<<query<<" on alignment "<<num_scores_processed<<" the score line is:"<<std::endl;
		  //std::cout<<"  ";

		  i = alignment_scores[num_scores_processed].score_start;
		  while ( file_buffers[index][i] != '\n' )
		    {
		      //std::cout<<file_buffers[index][i];
		      ++i;
		    }
		  //std::cout<<std::endl;
		  //std::cout.flush();

		  // advance the position in the buffer by 68 to start looking for the Score and Evalue.
		  pos += 68;

		  // Clean the char array used for holding the values.
		  for ( i=0; i < score_array_length; ++i )
		    score_array[i] = '\0';

		  // Look for the score string/value.
		  keep_looking = true;
		  while ( file_buffers[index][pos] != '\n' && keep_looking )
		    {
		      if ( file_buffers[index][pos] == ' ' )
			{
			  //std::cout<<"Found a space. Advancing pos and continuing the while loop."<<std::endl;
			  ++pos;
			  continue;
			}
		      else
			{
			  for ( i=0; i < score_array_length; ++i )
			    {
			      if ( file_buffers[index][pos] == ' ' || file_buffers[index][pos] == '\n' )
				{
				  //std::cout<<"found a blank or newline character -- stopping the for loop in the else branch"<<std::endl;
				  break;
				}
			      //std::cout<<"Adding "<<file_buffers[index][pos]<<" to the score_array"<<std::endl;
			      score_array[i] = file_buffers[index][pos];
			      ++pos;
			    }

			  if ( i == score_array_length )   // error: went too far looking for the end of the score.
			    {
			      std::cerr<<"ERROR: On query "<<query<<", the end of the Score could not be found correctly for alignment "<<num_scores_processed<<"."<<std::endl;
			      std::cerr<<"  The file this occurred in is "<<seq.filename<<" and the query sequence is "<<seq.id<<std::endl;
			      score_string.assign( score_array, i );
			      std::cerr<<"  The score_array contains: "<<score_string<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }

			  score_string.assign( score_array, i );   // Make a string from the array.
			  
			  // Get the numerical value.
			  alignment_scores[num_scores_processed].score = std::stod(score_string);

			  // done with the while loop.
			  keep_looking = false;
			}
			
		    }   // End of the while loop over the line (scanning while not '\n'). This looks for the score string.

		  //std::cout<<"The score string is "<<score_string<<" and the score value is "<<alignment_scores[num_scores_processed].score<<std::endl;
		  
		  // Clean the char array used for holding the values.
		  for ( i=0; i < score_array_length; ++i )
		    score_array[i] = '\0';

		  // Look for the evalue string/value.
		  keep_looking = true;
		  while ( file_buffers[index][pos] != '\n' && keep_looking )
		    {
		      if ( file_buffers[index][pos] == ' ' )
			{
			  ++pos;
			  continue;
			}
		      else
			{
			  for ( i=0; i < score_array_length; ++i )
			    {
			      if ( file_buffers[index][pos] == ' ' || file_buffers[index][pos] == '\n' )
				break;

			      score_array[i] = file_buffers[index][pos];
			      ++pos;
			    }

			  if ( i == score_array_length )   // error: went too far looking for the end of the evalue.
			    {
			      std::cerr<<"ERROR: On query "<<query<<", the end of the Evalue could not be found correctly."<<std::endl;
			      std::cerr<<"  The file this occurred in is "<<seq.filename<<" and the query sequence is "<<seq.id<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }

			  score_string.assign( score_array, i );   // Make a string from the array.
			  
			  // Get the numerical value.
			  alignment_scores[num_scores_processed].evalue = std::stod(score_string);

			  keep_looking = false;
			}
			
		    }   // End of the while loop over the line (scanning while not '\n'). This looks for the evalue string.

		  //std::cout<<"The evalue string is "<<score_string<<" and the evalue is "<<alignment_scores[num_scores_processed].evalue<<std::endl;

		  // Lastly, find the newline character to end this alignment's scores.
		  while ( pos < seq.offsets[2] && file_buffers[index][pos] != '\n' )
		    ++pos;

		  // found a newline, move the position up one.
		  ++pos;

		  if ( pos > seq.offsets[2] )
		    pos = seq.offsets[2];

		  alignment_scores[num_scores_processed].score_stop = pos;

		  if ( (alignment_scores[num_scores_processed].score_stop - alignment_scores[num_scores_processed].score_start) < 10 )
		    {
		      std::cerr<<"ERROR: On query "<<query<<", with id "<<seq.id<<", in file "<<seq.filename<<", the length of score line "<<num_scores_processed<<" is ";
		      std::cerr<<(alignment_scores[num_scores_processed].score_stop -alignment_scores[num_scores_processed].score_start)<<" bytes long."<<std::endl;
		      std::cerr.flush();
		      exit(1);
		    }

		  ++num_scores_processed;

		  if ( num_scores_processed >= num_scores )
		    break;   // Break the while loop since we have processed all alignment score lines for the query.

		}   // End of the while loop over the score lines block.

	      // Loop over the alignments in the current buffer.
	      pos = seq.offsets[3];

	      // The alignment_ptr tells us where to insert.
	      
	      while ( pos < seq.offsets[4] )
		{
		  // Record the start of the alignment.
		  alignment_scores[alignment_ptr].pairwise_start = pos;
		  
		  // Find the end of the output for the pairwise alignment.
		  
		  // Advance the position a couple of bytes to start looking for the end of the alignment.
		  pos += 2;
		  while ( pos < seq.offsets[4] )
		    {
		      if ( strncmp( &( file_buffers[index][pos] ), "\n\n\n>", 4 ) == 0 )
			{
			  alignment_scores[alignment_ptr].pairwise_stop = pos+2;

			  //std::cout<<"For query "<<query<<" on alignment "<<num_alignments_processed<<" the alignment is:"<<std::endl;
			  //std::cout<<"-----------------------------------------------------------------------------------"<<std::endl;
			  //for ( i=alignment_scores[alignment_ptr].pairwise_start; i < alignment_scores[alignment_ptr].pairwise_stop; ++i )
			  //{
			  //std::cout<<file_buffers[index][i];
			  //}
			  //std::cout<<"-----------------------------------------------------------------------------------"<<std::endl;
			  //std::cout<<std::endl<<std::endl;;
			  //std::cout.flush();
		
			  if ( (alignment_scores[alignment_ptr].pairwise_stop - alignment_scores[alignment_ptr].pairwise_start) < 10 )
			    {
			      std::cerr<<"ERROR: On query "<<query<<", with id "<<seq.id<<", in file "<<seq.filename<<", the length of alignment "<<num_alignments_processed<<" is ";
			      std::cerr<<(alignment_scores[alignment_ptr].pairwise_stop -alignment_scores[alignment_ptr].pairwise_start)<<" bytes long."<<std::endl;
			      std::cerr.flush();
			      exit(1);
			    }
	  
			  // Done with the alignment.
			  ++num_alignments_processed;
			  ++alignment_ptr;

			  pos = pos + 2;

			  // break out of loop.
			  break;
			}
		      else if ( strncmp( &( file_buffers[index][pos] ), "\n\n\n\nL", 5 ) == 0 )
			{
			  alignment_scores[alignment_ptr].pairwise_stop = pos+2;

			  //std::cout<<"For query "<<query<<" on alignment "<<num_alignments_processed<<" the alignment is:"<<std::endl;
			  //std::cout<<"-----------------------------------------------------------------------------------"<<std::endl;
			  //for ( i=alignment_scores[alignment_ptr].pairwise_start; i < alignment_scores[alignment_ptr].pairwise_stop; ++i )
			  //{
			  //std::cout<<file_buffers[index][i];
			  //}
			  //std::cout<<"-----------------------------------------------------------------------------------"<<std::endl;
			  //std::cout<<std::endl<<std::endl;;
			  //std::cout.flush();

			  // Done with the alignment.
			  ++num_alignments_processed;
			  ++alignment_ptr;

			  pos = seq.offsets[4];

			  // break out of loop.
			  break;
			}
		      
		      ++pos;
		    }

		}   // End of the while loop over the alignments block.


	    }   // End of the if test for hits present or not.

	}   // End of the iterator loop over the vector query_vector[query].

      // All alignments for the query in all files that pertain to the query have been recorded.

      //std::cout<<"Processed "<<num_scores_processed<<" score lines (description lines)."<<std::endl;
      //std::cout<<"Processed "<<num_alignments_processed<<" alignments."<<std::endl;

      /*
      if ( num_alignments != num_alignments_processed )
      {
        std::cerr<<"ERROR: for query "<<query<<", num_alignments("<<num_alignments<<") != num_alignments_processed(";
        std::cerr<<num_alignments_processed<<")."<<std::endl;
        std::cerr.flush();
        exit(1);
      }

      if ( num_alignments != num_scores_processed )
	{
	  std::cerr<<"ERROR: for query "<<query<<", num_alignments("<<num_alignments<<") != num_scores_processed(";
	  std::cerr<<num_scores_processed<<")."<<std::endl;
	  std::cerr.flush();
	  exit(1);
	}

      if ( num_scores_processed != num_alignments_processed )
	{
	  std::cerr<<"ERROR: for query "<<query<<", num_alignments_processed("<<num_alignments_processed<<") != num_scores_processed(";
	  std::cerr<<num_scores_processed<<")."<<std::endl;
	  std::cerr.flush();
	  exit(1);
	}
      */

      // We expect that the number if scores processed should equal the number of scores seen.
      if ( num_scores_processed != num_scores )
	{
	  std::cerr<<"ERROR: for query "<<query<<", num_scores_processed("<<num_scores_processed<<") != num_scores(";
	  std::cerr<<num_scores<<")."<<std::endl;
	  std::cerr.flush();
	  exit(1);
	}
      

      //for ( i=0; i < num_scores; ++i )
      //{
      //std::cout<<alignment_scores[i].score<<"  "<<alignment_scores[i].evalue<<std::endl;
      //}
      
      // Fourth: sort the alignments by ascending scores ( bit scores; descending evalue for the tie breaker ).
      qsort( alignment_scores, num_scores, sizeof( struct score_info ), compare_scores );

      //std::cout<<"After sort......"<<std::endl<<std::endl;

      //for ( i=0; i < num_scores; ++i )
      //{
      //std::cout<<alignment_scores[i].score<<"  "<<alignment_scores[i].evalue<<std::endl;
      //}

      // Fifth: write out the score lines and alignments for the query in the sorted order.

      // Loop over the alignments and write out (a) the score lines and (b) the pairwise alignments.

      // NOTE THAT, BY DEFAULT, BLAST LIMITS SCORES TO THE TOP 500 AND ALIGNMENTS TO THE TOP 250.

      // ---****---  Ignore the limit.
      if ( num_scores_processed > 500 )
	{
	  num_scores_processed = 500;

	  //std::cout<<"  Clamping the number of score lines (descriptions) to 500."<<std::endl;
	}


      for ( i=0; i < num_scores_processed; ++i )
	{
	  // Grab the sorted alignment. This indexes into the unsorted alignments array.
	  uint64_t index = alignment_scores[i].index;

	  pos_beg = alignment_scores[i].score_start;
	  pos_end = alignment_scores[i].score_stop;

	  length_to_write = pos_end - pos_beg;

	  if ( length_to_write < 1 )
	    {
	      std::cerr<<"ERROR: for query "<<query<<", and ID "<<query_name<<", "<<" with unsorted index "<<index<<", the length of the score line to write is "<<length_to_write<<std::endl;
	      std::cerr.flush();
	      exit(1);
	    }

	  // Retrieve the file index before writing.
	  index = alignment_scores[i].file_index;

	  ofs.write( &(file_buffers[index][pos_beg]), length_to_write );
	}

      ofs.write("\n\n",2);

      if ( num_alignments_processed > 250 )
	{
	  num_alignments_processed = 250;

	  //std::cout<<"  Clamping the number of alignments to 250."<<std::endl;
	}

      for ( i=0; i < num_alignments_processed; ++i )
	{
	  // Grab the sorted alignment.
	  uint64_t index = alignment_scores[i].index;

	  pos_beg = alignment_scores[i].pairwise_start;
	  pos_end = alignment_scores[i].pairwise_stop;

	  length_to_write = pos_end - pos_beg;

	  if ( length_to_write < 1 )
	    {
	      std::cerr<<"ERROR: for query "<<query<<" with unsorted index "<<index<<" and ID "<<query_name<<", the length of the alignment to write is "<<length_to_write<<std::endl;
	      std::cerr<<"       This alignment is "<<i<<" out of a total of "<<num_alignments_processed<<std::endl;
	      std::cerr<<"       The corresponding score line is:"<<std::endl;
	      std::cerr<<"       ";

	      // Write out the 'corresponding' score line.
	      pos_beg = alignment_scores[i].score_start;
	      pos_end = alignment_scores[i].score_stop;

	      index = alignment_scores[i].file_index;

	      for ( i=pos_beg; i < pos_end; ++i )
		std::cerr<<file_buffers[index][i];
	      std::cerr<<std::endl;

	      std::cerr.flush();
	      //exit(1);
	    }

	  // Retrieve the file index before writing.
	  if ( length_to_write > 0 )
	    index = alignment_scores[i].file_index;
	  
	  if ( length_to_write > 0 )
	    ofs.write( &(file_buffers[index][pos_beg]), length_to_write );
	}

      // Write the query epilogue.
      for ( std::vector<sequence>::const_iterator it = query_vector[query].begin(); it != query_vector[query].end(); ++it )
	{
	  const sequence &seq = *it;
	  
	  if ( seq.offsets[1] != 0 )
	    {
	      // Get the value (index) from the map.
	      std::map<std::string,int>::const_iterator map_iter;
	      
	      map_iter = filenames_map.find( seq.filename );
	      
	      //std::cout<<"   Looking in file "<<filename<<std::endl;
	      //std::cout<<"    corresponds to file index "<<map_iter->second<<std::endl;
	      //std::cout<<"    seq.offsets[4]="<<seq.offsets[4]<<" seq.offsets[5]="<<seq.offsets[5]<<std::endl;
	      
	      uint64_t index = map_iter->second;
	      
	      pos = seq.offsets[4];
	      length_to_write = seq.offsets[5] - seq.offsets[4];
	      
	      ofs.write( &(file_buffers[index][pos]), length_to_write );
	      
	      it = query_vector[query].end();

	      break;
	    }
	}

      // Clean out memory and data structures for the next go around.
      delete []file_lengths;
      file_lengths = 0;

      delete [] alignment_scores;
      alignment_scores = 0;

      for ( i=0; i < num_files; ++i )
	{
	  delete [] file_buffers[i];
	}
      
      delete [] file_buffers;
      file_buffers = 0;

      num_files = 0;
      total_buffer_length = 0;

      filenames_map.clear();

    }   // End of the loop over the queries.

  // Write the epilogue.
  ofs.write( &(epilogue[0]), epi_length );

  // Close the file.
  ofs.close();

  delete [] buffer;

  return 0;
}
